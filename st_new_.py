# -*- coding: utf-8 -*-
"""st_new_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pJl3aux3Fn3U9Dx5ZSUB69rgvjgpc4jA
"""

#importing all the libraries required
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.metrics import r2_score, mean_squared_error
from sklearn.metrics import mean_absolute_percentage_error, mean_squared_error
import numpy as np

from sklearn.tree import DecisionTreeRegressor
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from matplotlib import pyplot as plt
import datetime as dt
pd.options.mode.chained_assignment = None
import math
import numpy as np
from statsmodels.api import OLS
import statsmodels.api as sm
from sklearn.metrics import mean_squared_error, r2_score
from mlxtend.feature_selection import SequentialFeatureSelector as SFS
from sklearn.linear_model import LinearRegression
import os
import matplotlib.ticker as ticker
import matplotlib.ticker as mticker
import plotly.express as px
import plotly.graph_objects as go
import streamlit as st

path =
df = pd.read_csv(path)

# Global variables
seed = 0  # For setting the random state
sample_size = 0.4
test_size = 0.3
target = 'meter_sale_price'

mq1 = df['meter_sale_price'].quantile(0.25)
mq3 = df['meter_sale_price'].quantile(0.75)
IQR = mq3 - mq1
mlower_bound = mq1 - 1.5 * IQR
mupper_bound = mq3 + 1.5 * IQR
pq1 = df['procedure_area'].quantile(0.25)
pq3 = df['procedure_area'].quantile(0.75)
IQR = pq3 - pq1
plower_bound = pq1 - 1.5 * IQR
pupper_bound = pq3 + 1.5 * IQR
aq1 = df['actual_worth'].quantile(0.25)
aq3 = df['actual_worth'].quantile(0.75)
IQR = aq3 - aq1
alower_bound = aq1 - 1.5 * IQR
aupper_bound = aq3 + 1.5 * IQR
otdf = df[(df['meter_sale_price'] >= mlower_bound ) & (df['meter_sale_price'] < mupper_bound)]
odf = otdf[(otdf['procedure_area'] >= plower_bound) & (otdf['procedure_area'] < pupper_bound)]

"""# Stream lit show"""

st.set_page_config(page_title="Multi-File Data Dashboard", layout="wide")
st.title("ðŸ“ Multi-Source Data Exploration Dashboard")

with st.expander("ðŸ” Preview Data"):
    st.dataframe(df)
    st.subheader("ðŸ“‹ Data Summary")
    summary = pd.DataFrame({
        "Column": df.columns,
        "Data Type": [str(df[col].dtype) for col in df.columns],
        "Null Count": df.isnull().sum().values,
        "Null %": (df.isnull().mean().values * 100).round(2),
        "Unique Values": df.nunique().values
    })

"""# Bubble plot"""

# ---- Streamlit Page Setup ----
st.set_page_config(layout="wide")
st.title("ðŸ“ Comparative Bubble Maps: DF (Top) vs ODF (Bottom)")

# ---- Check and Load Datasets ----
datasets = {}
if 'df' in locals():
    datasets['DF'] = df.copy()
if 'odf' in locals():
    datasets['ODF'] = odf.copy()

if not datasets:
    st.error("No datasets named 'df' or 'odf' found in the environment.")
    st.stop()

# ---- Preprocessing Function ----
def prepare_bubble_data(data):
    data['area_lat'] = pd.to_numeric(data['area_lat'], errors='coerce')
    data['area_lon'] = pd.to_numeric(data['area_lon'], errors='coerce')
    data.dropna(subset=['area_lat', 'area_lon', 'meter_sale_price'], inplace=True)

    grouped = data.groupby(['area_name_en', 'area_lat', 'area_lon'])['meter_sale_price'] \
                 .agg(['count', 'mean']).reset_index()
    grouped.rename(columns={'count': 'Record Count', 'mean': 'Average Meter Sale Price'}, inplace=True)
    return grouped

# ---- Generate and Display Maps Vertically ----
for label, data in datasets.items():
    st.subheader(f"{label} - Bubble Map")
    bubble_data = prepare_bubble_data(data)

    fig = px.scatter_mapbox(
        bubble_data,
        lat='area_lat',
        lon='area_lon',
        hover_name='area_name_en',
        hover_data={'Record Count': True, 'Average Meter Sale Price': True},
        color='Average Meter Sale Price',
        size='Record Count',
        size_max=50,
        color_continuous_scale='Viridis',
        zoom=10,
        mapbox_style='open-street-map'
    )

    st.plotly_chart(fig, use_container_width=True)

"""# Removing function to create plots"""

# Example: Load your data if not already in memory
# df = pd.read_csv("path_to_df.csv")
# odf = pd.read_csv("path_to_odf.csv")

# ---- Streamlit App Interface ----
st.set_page_config(layout="wide")
st.title("ðŸ“ˆ Comparative Target Distribution by Transaction Group")

try:
    # Use existing df and odf
    dfs = [df, odf]
    df_names = ['DF', 'DF after outliers']

    target_column = st.text_input("Enter the target column name", value="Meter_Sale_Price")

    if st.button("Generate Plots"):
        for i, df in enumerate(dfs):
            df_name = df_names[i]
            st.header(f"ðŸ“Š Distribution for: {df_name}")

            # --- Box Plot by trans_group_en ---
            st.subheader("Box Plot by Transaction Group")
            fig_box = px.box(df, x='trans_group_en', y=target_column,
                             title=f'Box Plot of {target_column} by Transaction Group ({df_name})')
            fig_box.update_layout(
                xaxis_title="Transaction Group",
                yaxis_title="Meter Sale Price (AED)",
                yaxis_tickformat=","
            )
            st.plotly_chart(fig_box, use_container_width=True)

            # --- Line Plot: instance_year vs target_column with trans_group_en as legend ---
            st.subheader("Line Plot by Year and Transaction Group")
            year_col = 'instance_year' if 'instance_year' in df.columns else 'instance_Year'
            if year_col in df.columns:
                grouped_data = df.groupby([year_col, 'trans_group_en'])[target_column].mean().reset_index()

                fig_line = px.line(
                    grouped_data, x=year_col, y=target_column, color='trans_group_en',
                    title=f'Year-wise {target_column} by Transaction Group ({df_name})'
                )
                fig_line.update_layout(
                    xaxis_title="Year",
                    yaxis_title="Meter Sale Price (AED)",
                    yaxis_tickformat=",",
                    legend_title="Transaction Group"
                )
                fig_line.update_xaxes(showgrid=True, gridwidth=1, gridcolor='lightgray')
                fig_line.update_yaxes(showgrid=True, gridwidth=1, gridcolor='lightgray')
                st.plotly_chart(fig_line, use_container_width=True)
            else:
                st.warning(f"Year column not found in {df_name}")

except NameError:
    st.error("Make sure variables 'df' and 'odf' are loaded in your environment or defined in the app.")